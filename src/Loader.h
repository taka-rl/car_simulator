#ifndef LOADER_H
#define LOADER_H


#include <glad/glad.h>
#include <iostream>
using namespace std;

/*
TODO: Deepen the understanding of VBO, VAO and EBO later.
- VBO
VBO, which stands for Vertex Buffer Objects, can store a large number of vertices in the GPU's memory. 
A vertex buffer object has a unique ID corresponding to that buffer. The unique ID can be generated by `glGenBuffers` function.
`glBindBuffer` function is used to bind the newly created buffer to the `GL_ARRAY_BUFFER` target. --> glBindBuffer(GL_ARRAY_BUFFER, VBO);
`glBufferData` function is used to copy user-defined data into the currently bound buffer.  --> glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
- VAO
VAO, which stands for Vertex Array Objects, can be bound just like a vertex buffer object.
This has the advantage that when configuring vertex attribute pointers you only have to make those calls once and whenever we want to draw the object, 
we can just bind the corresponding VAO. This makes switching between different vertex data and attribute configurations as easy as binding a different VAO. 
A vertex array object can be stored in the following steps.
1. Calls to glEnableVertexAttribArray or glDisableVertexAttribArray.
2. Vertex attribute configurations via glVertexAttribPointer.
3. Vertex buffer objects associated with vertex attributes by calls to glVertexAttribPointer.
- EBO
EBO, which stands for Element Buffer Objects, is a buffer same as a vertex buffer object.
    glGenBuffers(1, &EBO);
A element buffer object can be stored in the following steps.
1. Define the element buffer object --> glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
2. Similar to the VBO, the EBO needs to be bound and the indices are copied into the buffer with `glBindBuffer` and `glBufferData` functions.
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

`glDrawElements` function takes its indices from the EBO bound to the GL_ELEMENT_ARRAY_BUFFER target. 
This means we have to bind the corresponding EBO each time we want to render an object with indices which again is a bit cumbersome. 
It just so happens that a vertex array object also keeps track of element buffer object bindings. 
The last element buffer object that gets bound while a VAO is bound, is stored as the VAO's element buffer object. 
Binding to a VAO then also automatically binds that EBO.

*/


class Loader {

private:
    unsigned int vbo, vao, ebo;

public:
    // constructor generates the shader on the fly
    // ------------------------------------------------------------------------
    Loader(float vertices[], size_t vertexCount, unsigned int indices[], size_t indexCount);
    // destructor
    // ------------------------------------------------------------------------
    ~Loader();

    // getter for VBO, VAO, EBO
    // ------------------------------------------------------------------------
    unsigned int getVBO();
    unsigned int getVAO();
    unsigned int getEBO();

    // create VBO, VAO, EBO
    // ------------------------------------------------------------------------
    unsigned int makeVBO();
    unsigned int makeVAO();
    unsigned int makeEBO();

};
#endif

